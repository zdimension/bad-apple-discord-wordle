#!/usr/bin/env python3
"""
Process badapple.mp4 to generate JavaScript code for Wordle grid animation.
"""

import subprocess
import os
import sys
from PIL import Image
import shutil

# Configuration
VIDEO_FILE = "badapple.mp4"
TARGET_WIDTH = 9
TARGET_HEIGHT = 6
TARGET_FPS = 15  # Target frames per second
TEMP_FOLDER = "/tmp/badapple_wordle_frames"  # tmpfs
OUTPUT_FILE = "wordle.js"
MAX_FRAMES = 500  # For testing, process only first 50 frames

def ensure_temp_folder():
    """Create temp folder if it doesn't exist, clean it if it does."""
    if os.path.exists(TEMP_FOLDER):
        shutil.rmtree(TEMP_FOLDER)
    os.makedirs(TEMP_FOLDER)
    print(f"Created temp folder: {TEMP_FOLDER}")

def extract_frames():
    """Extract frames from video using ffmpeg, rescaling to target dimensions."""
    print(f"Extracting frames from {VIDEO_FILE}...")
    
    # Use ffmpeg to extract frames, rescale, and convert to grayscale
    cmd = [
        "ffmpeg",
        "-i", VIDEO_FILE,
        "-vf", f"fps={TARGET_FPS},scale={TARGET_WIDTH}:{TARGET_HEIGHT}:flags=lanczos,format=gray",
        "-frames:v", str(MAX_FRAMES),
        os.path.join(TEMP_FOLDER, "frame_%04d.png")
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"Error running ffmpeg: {result.stderr}")
        sys.exit(1)
    
    print(f"Extracted {MAX_FRAMES} frames successfully")

def load_frame(frame_num):
    """Load a frame and convert to binary (black/white) pixels."""
    filename = os.path.join(TEMP_FOLDER, f"frame_{frame_num:04d}.png")
    img = Image.open(filename).convert('L')  # Convert to grayscale
    
    # Convert to binary: threshold at 128
    pixels = []
    for y in range(img.height):
        row = []
        for x in range(img.width):
            pixel = img.getpixel((x, y))
            # 0 = black, 1 = white
            row.append(1 if pixel > 128 else 0)
        pixels.append(row)
    
    return pixels

def get_pixel_diff(frame1, frame2):
    """Get list of pixels that differ between two frames."""
    diff = []
    for y in range(len(frame1)):
        for x in range(len(frame1[0])):
            if frame1[y][x] != frame2[y][x]:
                diff.append((x, y, frame2[y][x]))
    return diff

def generate_js_code():
    """Generate the JavaScript code for Wordle animation."""
    print("Generating JavaScript code...")
    
    lines = []
    
    # Header
    lines.append("// Auto-generated by process_wordle.py")
    lines.append("// Bad Apple animation for Wordle grid")
    lines.append("// Paste this in browser console with a .BoardContainer element selected as $0")
    lines.append("")
    
    # Load all frames
    frames = []
    for i in range(1, MAX_FRAMES + 1):
        frame = load_frame(i)
        frames.append(frame)
        print(f"Loaded frame {i}/{MAX_FRAMES}")
    
    if not frames:
        print("Error: No frames loaded!")
        sys.exit(1)
    
    height = len(frames[0])
    width = len(frames[0][0])
    
    # Setup code
    lines.append("(function() {")
    lines.append("  // Setup container")
    lines.append("  const container = $0;")
    lines.append("  container.style.width = '120px';")
    lines.append("  container.style.setProperty('--h-count', '9');")
    lines.append("")
    lines.append("  // Get grid wrapper and clear it")
    lines.append("  const gridWrapper = container.querySelector('.BoardGridWrapped');")
    lines.append("  gridWrapper.innerHTML = '';")
    lines.append("")
    lines.append("  // Create tile elements")
    lines.append("  const tiles = [];")
    lines.append(f"  for (let i = 0; i < {width * height}; i++) {{")
    lines.append("    const tile = document.createElement('div');")
    lines.append("    tile.className = 'TileContainer TileStateAbsent';")
    lines.append("    tile.setAttribute('role', 'img');")
    lines.append("    gridWrapper.appendChild(tile);")
    lines.append("    tiles.push(tile);")
    lines.append("  }")
    lines.append("")
    
    # Generate frame data as strings
    lines.append("  // Frame data (0=white/absent, 1=black/correct)")
    lines.append("  const data = [")
    
    for frame_num, frame in enumerate(frames, 1):
        # Convert frame to string of 0s and 1s
        frame_str = ""
        for y in range(height):
            for x in range(width):
                frame_str += str(frame[y][x])
        
        lines.append(f'    "{frame_str}",  // Frame {frame_num}')
        print(f"Encoded frame {frame_num}/{MAX_FRAMES}")
    
    lines.append("  ];")
    lines.append("")
    
    # Rendering function
    lines.append("  // Render a frame")
    lines.append("  function renderFrame(frameIndex) {")
    lines.append("    const frameData = data[frameIndex];")
    lines.append("    for (let i = 0; i < tiles.length; i++) {")
    lines.append("      const pixel = frameData[i];")
    lines.append("      if (pixel === '0') {")
    lines.append("        tiles[i].className = 'TileContainer TileStateAbsent';")
    lines.append("      } else {")
    lines.append("        tiles[i].className = 'TileContainer TileStateCorrect';")
    lines.append("      }")
    lines.append("    }")
    lines.append("  }")
    lines.append("")
    
    # Animation loop
    frame_duration_ms = 1000 // TARGET_FPS
    lines.append("  // Animation loop")
    lines.append("  let currentFrame = 0;")
    lines.append(f"  const FPS = {TARGET_FPS};")
    lines.append(f"  const FRAME_DURATION = {frame_duration_ms};  // ms")
    lines.append("")
    lines.append("  function animate() {")
    lines.append("    const startTime = performance.now();")
    lines.append("    ")
    lines.append("    function nextFrame() {")
    lines.append("      renderFrame(currentFrame);")
    lines.append("      currentFrame++;")
    lines.append("      ")
    lines.append("      // Stop at last frame")
    lines.append("      if (currentFrame >= data.length) {")
    lines.append("        console.log('Animation complete!');")
    lines.append("        return;")
    lines.append("      }")
    lines.append("      ")
    lines.append("      const elapsed = performance.now() - startTime;")
    lines.append("      const targetTime = currentFrame * FRAME_DURATION;")
    lines.append("      const delay = Math.max(0, targetTime - elapsed);")
    lines.append("      ")
    lines.append("      requestAnimationFrame(() => {")
    lines.append("        setTimeout(nextFrame, delay);")
    lines.append("      });")
    lines.append("    }")
    lines.append("    ")
    lines.append("    nextFrame();")
    lines.append("  }")
    lines.append("")
    lines.append("  // Start animation after 5 seconds")
    lines.append("  console.log('Bad Apple animation will start in 5 seconds...');")
    lines.append(f"  console.log('Resolution: {width}x{height}, FPS: {TARGET_FPS}, Frames: {MAX_FRAMES}');")
    lines.append("  setTimeout(() => {")
    lines.append("    console.log('Starting animation now!');")
    lines.append("    animate();")
    lines.append("  }, 5000);")
    lines.append("})();")
    
    # Write to file
    with open(OUTPUT_FILE, 'w') as f:
        f.write('\n'.join(lines))
    
    print(f"Generated {OUTPUT_FILE}")
    print(f"Total frames: {MAX_FRAMES}, Resolution: {width}x{height}, FPS: {TARGET_FPS}")

def main():
    print("=" * 60)
    print("Bad Apple Wordle Video Processor")
    print("=" * 60)
    
    # Check if video file exists
    if not os.path.exists(VIDEO_FILE):
        print(f"Error: {VIDEO_FILE} not found!")
        sys.exit(1)
    
    # Step 1: Prepare temp folder
    ensure_temp_folder()
    
    # Step 2: Extract frames
    extract_frames()
    
    # Step 3: Generate JavaScript code
    generate_js_code()
    
    print("=" * 60)
    print("Done!")
    print("=" * 60)

if __name__ == "__main__":
    main()

